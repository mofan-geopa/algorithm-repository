# 44. 开发商购买土地

## 题目描述

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 

1 2 3 

2 1 3 

1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 

2 1 | 3 

1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。



## 代码

```C++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;
int main () {
    int n, m;
    cin >> n >> m;
    int sum = 0;
    vector<vector<int>> vec(n, vector<int>(m, 0)) ;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> vec[i][j];
            sum += vec[i][j];
        }
    }
    // 统计横向
    vector<int> horizontal(n, 0);
    for (int i = 0; i < n; i++) {
        for (int j = 0 ; j < m; j++) {
            horizontal[i] += vec[i][j];
        }
    }
    // 统计纵向
    vector<int> vertical(m , 0);
    for (int j = 0; j < m; j++) {
        for (int i = 0 ; i < n; i++) {
            vertical[j] += vec[i][j];
        }
    }
    int result = INT_MAX;
    int horizontalCut = 0;
    for (int i = 0 ; i < n; i++) {
        horizontalCut += horizontal[i];
        result = min(result, abs(sum - horizontalCut - horizontalCut));
    }
    int verticalCut = 0;
    for (int j = 0; j < m; j++) {
        verticalCut += vertical[j];
        result = min(result, abs(sum - verticalCut - verticalCut));
    }
    cout << result << endl;
}
```

时间复杂度： O(n^2)



## 解析

这段代码的核心功能是：给定一个 `n x m` 的二维矩阵，计算通过**横向切割**或**纵向切割**将矩阵分成两部分后，两部分元素总和的最小差值。

总体功能概述

程序首先读取矩阵的行列数和元素值，计算出所有元素的总和。然后分别计算每行的横向累加和与每列的纵向累加和，模拟在任意位置进行切割，找到使得两部分总和差值最小的那个值并输出。

1. **变量初始化与矩阵输入**

    ```cpp
    int n, m;
    cin >> n >> m;
    int sum = 0;
    vector<vector<int>> vec(n, vector<int>(m, 0)) ;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> vec[i][j];
            sum += vec[i][j]; // 累加所有元素得到总和
        }
    }
    ```

    - 读取矩阵的行数 `n` 和列数 `m`。
    - 定义二维向量 `vec` 存储矩阵元素，同时用 `sum` 累加所有元素的总和。

2. **计算每行的横向总和**

    ```cpp
    vector<int> horizontal(n, 0);
    for (int i = 0; i < n; i++) {
        for (int j = 0 ; j < m; j++) {
            horizontal[i] += vec[i][j]; // 第i行的元素总和
        }
    }
    ```

    - 用 `horizontal` 数组存储每行的元素总和，`horizontal[i]` 表示第 `i` 行的总和。

3. **计算每列的纵向总和**

    ```cpp
    vector<int> vertical(m , 0);
    for (int j = 0; j < m; j++) {
        for (int i = 0 ; i < n; i++) {
            vertical[j] += vec[i][j]; // 第j列的元素总和
        }
    }
    ```

    - 用 `vertical` 数组存储每列的元素总和，`vertical[j]` 表示第 `j` 列的总和。

4. **寻找最小切割差值**

    ```cpp
    int result = INT_MAX; // 初始化为整型最大值，用于存储最小差值
    
    // 横向切割：模拟在第i行下方切割，前i+1行总和为horizontalCut
    int horizontalCut = 0;
    for (int i = 0 ; i < n; i++) {
        horizontalCut += horizontal[i];
        result = min(result, abs(sum - horizontalCut - horizontalCut));
        // sum - horizontalCut 是切割后另一部分的总和，差值为 |总和 - 2*前半部分和|
    }
    
    // 纵向切割：模拟在第j列右侧切割，前j+1列总和为verticalCut
    int verticalCut = 0;
    for (int j = 0; j < m; j++) {
        verticalCut += vertical[j];
        result = min(result, abs(sum - verticalCut - verticalCut));
    }
    
    cout << result << endl; // 输出最小差值
    ```

    - **横向切割逻辑**：`horizontalCut` 累加每行的和，代表 “切割线以上部分的总和”。两部分差值为 `|总和 - 2*horizontalCut|`（因为总和 = 前半部分 + 后半部分，差值 = | 前半部分 - 后半部分 | = |2 * 前半部分 - 总和 |）。
    - **纵向切割逻辑**：与横向切割原理一致，只是按列累加。
    - 最终 `result` 存储横向和纵向切割中最小的差值。

输入与输出分析

- **输入**：第一行输入两个整数 `n`（行数）和 `m`（列数），接下来 `n` 行每行输入 `m` 个整数，表示矩阵元素。
- **输出**：切割后两部分元素总和的最小差值。

**示例输入**：

```plaintext
2 2
1 2
3 4
```

**计算过程**：

- 总和 `sum = 1+2+3+4 = 10`。
- 横向切割：第一行和为 3，差值 `|10-6|=4`；两行总和为 10，差值 `|10-20|=10` → 横向最小差值 4。
- 纵向切割：第一列和为 4，差值 `|10-8|=2`；两列总和为 10，差值 10 → 纵向最小差值 2。
- 最终输出：`2`。









